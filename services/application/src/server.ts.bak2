import 'dotenv/config';
import express from 'express';
import { json } from 'express';
import cors from 'cors';
import { z } from 'zod';
import { v4 as uuidv4 } from 'uuid';
import { createPgPool, correlationIdMiddleware, createLogger, metricsMiddleware, metricsHandler } from '@los/shared-libs';

import { setupApplicationSSE, broadcastApplicationUpdate } from './sse-handler';
import { setupRMDashboardEndpoint } from './rm-dashboard';
import { setupHierarchicalDashboards } from './hierarchical-dashboards';

// Export pool and app for testing
// Ensure DATABASE_URL is set before creating pool
if (!process.env.DATABASE_URL) {
  process.env.DATABASE_URL = 'postgres://los:los@localhost:5432/los';
  console.warn('⚠️  DATABASE_URL not set, using default: postgres://los:los@localhost:5432/los');
}
export const pool = createPgPool();
const logger = createLogger('application-service');

export const app = express();

// CORS configuration
const corsOptions = {
  origin: process.env.CORS_ORIGIN?.split(',') || ['http://localhost:5000', 'http://localhost:5173'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Correlation-ID', 'Idempotency-Key'],
  maxAge: 86400 // 24 hours
};
app.use(cors(corsOptions));

app.use(json());
app.use(correlationIdMiddleware);
app.use(metricsMiddleware);

// Helper function to record application history
async function recordHistory(
  applicationId: string,
  eventType: string,
  eventSource: string,
  eventData: any,
  actorId?: string
) {
  try {
    const historyId = uuidv4();
    const userId = actorId || 'system';
    await pool.query(
      `INSERT INTO application_history 
       (history_id, application_id, event_type, event_source, event_data, actor_id)
       VALUES ($1, $2, $3, $4, $5, $6)`,
      [historyId, applicationId, eventType, eventSource, JSON.stringify(eventData), userId]
    );
  } catch (err) {
    logger.error('RecordHistoryError', { error: (err as Error).message, applicationId, eventType });
    // Don't fail the main operation if history recording fails
  }
}

app.get('/health', (_req, res) => res.status(200).send('OK'));
app.get('/metrics', metricsHandler);

const CreateApplicationSchema = z.object({
  applicantId: z.string().uuid(),
  channel: z.enum(['Branch', 'DSA', 'Online', 'Mobile']),
  productCode: z.string().min(1),
  requestedAmount: z.number().positive(),
  requestedTenureMonths: z.number().int().positive()
});

const UpdateApplicationSchema = z.object({
  channel: z.enum(['Branch', 'DSA', 'Online', 'Mobile']).optional(),
  productCode: z.string().min(1).optional(),
  requestedAmount: z.number().positive().optional(),
  requestedTenureMonths: z.number().int().positive().optional()
});

// Helper function to fetch and validate product limits
async function validateProductLimits(productCode: string, requestedAmount: number, requestedTenureMonths: number): Promise<{ valid: boolean; error?: string }> {
  try {
    // Fetch product details from masters service
    const mastersUrl = process.env.MASTERS_SERVICE_URL || 'http://localhost:3005';
    // CRITICAL: Add timeout to prevent hanging - this was causing the 30s timeout!
    const timeoutMs = 2000; // 2 second timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
    
    try {
          const response = await fetch(`${mastersUrl}/api/masters/products/${productCode}`, {

        signal: controller.signal,
        headers: { 'Content-Type': 'application/json' }
      });
    
      clearTimeout(timeoutId);
    
    if (!response.ok) {
      if (response.status === 404) {
        return { valid: false, error: `Product ${productCode} not found` };
      }
      return { valid: false, error: 'Failed to validate product limits' };
    }
    
    const product = await response.json();
    
    // Validate amount limits
    if (requestedAmount < Number(product.min_amount)) {
      return { valid: false, error: `Requested amount ${requestedAmount} is below minimum ${product.min_amount} for product ${productCode}` };
    }
    if (requestedAmount > Number(product.max_amount)) {
      return { valid: false, error: `Requested amount ${requestedAmount} exceeds maximum ${product.max_amount} for product ${productCode}` };
    }
    
    // Validate tenure limits
    if (requestedTenureMonths < product.min_tenure_months) {
      return { valid: false, error: `Requested tenure ${requestedTenureMonths} months is below minimum ${product.min_tenure_months} months for product ${productCode}` };
    }
    if (requestedTenureMonths > product.max_tenure_months) {
      return { valid: false, error: `Requested tenure ${requestedTenureMonths} months exceeds maximum ${product.max_tenure_months} months for product ${productCode}` };
    }
    
    return { valid: true };
    } catch (fetchErr: any) {
      clearTimeout(timeoutId);
      if (fetchErr.name === 'AbortError') {
        logger.warn('ProductValidationTimeout', { productCode, timeout: timeoutMs });
      } else {
        logger.warn('ProductValidationError', { error: (fetchErr as Error).message, productCode });
      }
      return { valid: true };
    }
  } catch (err) {
    logger.warn('ProductValidationError', { error: (err as Error).message, productCode });
    // If masters service is unavailable, skip validation (fail-open for resilience)
    // In production, you might want to fail-closed instead
    return { valid: true };
  }
}

// POST /api/applications - create
app.post('/api/applications', async (req, res) => {
  const parsed = CreateApplicationSchema.safeParse(req.body);
  if (!parsed.success) {
    return res.status(400).json({ error: 'Invalid payload', details: parsed.error.flatten() });
  }

  // Validate product limits
  const validation = await validateProductLimits(parsed.data.productCode, parsed.data.requestedAmount, parsed.data.requestedTenureMonths);
  if (!validation.valid) {
    return res.status(400).json({ error: validation.error });
  }

  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    
    // Generate application ID in format: ProductCode + SerialNumber (e.g., HL00001, PL00042)
    const idResult = await client.query(
      'SELECT generate_application_id($1) as application_id',
      [parsed.data.productCode]
    );
    const id = idResult.rows[0].application_id;    
    if (applicantRows.length === 0) {
      // Create minimal applicant record in same transaction
      await client.query(
        `INSERT INTO applicants (applicant_id, first_name, last_name, created_at, updated_at) 
         VALUES ($1, $2, $3, now(), now()) 
         ON CONFLICT (applicant_id) DO NOTHING`,
        [parsed.data.applicantId, 'New', 'Applicant']
      );
      logger.info('Created minimal applicant', { applicantId: parsed.data.applicantId, correlationId: (req as any).correlationId });
    }
    
    // Persist application
    // Write outbox event in same transaction
    const eventId = uuidv4();
    await client.query(
      'INSERT INTO outbox (id, aggregate_id, topic, event_type, payload, headers) VALUES ($1, $2, $3, $4, $5, $6)',
      [eventId, id, 'los.application.ApplicationCreated.v1', 'los.application.ApplicationCreated.v1', JSON.stringify({ applicationId: id, ...parsed.data }), JSON.stringify({ correlationId: (req as any).correlationId })]
    );

    await client.query('COMMIT');
    
    // Record history (non-blocking)
    const actorId = (req as any).user?.id || (req as any).user?.sub || 'system';
    await recordHistory(id, 'ApplicationCreated', 'application', { ...parsed.data, status: 'Draft' }, actorId);
    
    logger.info('CreateApplication', { correlationId: (req as any).correlationId, applicationId: id });
    return res.status(201).json({ applicationId: id, status: 'Draft' });
  } catch (err) {
    await client.query('ROLLBACK');
    logger.error('CreateApplicationError', { error: (err as Error).message, correlationId: (req as any).correlationId });
    return res.status(500).json({ error: 'Failed to create application' });
  } finally {
    client.release();
  }
});

// GET /api/applications - list with filters and pagination
app.get('/api/applications', async (req, res) => {
  try {
    const page = Math.max(1, parseInt(req.query.page as string || '1', 10));
    const limit = Math.min(100, Math.max(1, parseInt(req.query.limit as string || '20', 10)));
    const offset = (page - 1) * limit;

    // Build WHERE clause dynamically
    const conditions: string[] = [];
    const values: any[] = [];
    let paramCount = 1;

    if (req.query.status) {
      // Support comma-separated statuses for advanced search
      const statuses = (req.query.status as string).split(',').map(s => s.trim());
      if (statuses.length === 1) {
        conditions.push(`status = $${paramCount++}`);
        values.push(statuses[0]);
      } else {
        conditions.push(`status = ANY($${paramCount++})`);
        values.push(statuses);
      }
    }
    if (req.query.channel) {
      conditions.push(`channel = $${paramCount++}`);
      values.push(req.query.channel);
    }
    if (req.query.productCode) {
      conditions.push(`product_code = $${paramCount++}`);
      values.push(req.query.productCode);
    }
    if (req.query.applicantId) {
      conditions.push(`applicant_id = $${paramCount++}`);
      values.push(req.query.applicantId);
    }
    if (req.query.minAmount) {
      conditions.push(`requested_amount >= $${paramCount++}`);
      values.push(parseFloat(req.query.minAmount as string));
    }
    if (req.query.maxAmount) {
      conditions.push(`requested_amount <= $${paramCount++}`);
      values.push(parseFloat(req.query.maxAmount as string));
    }
    // Date range filters
    if (req.query.startDate) {
      conditions.push(`created_at >= $${paramCount++}`);
      values.push(req.query.startDate);
    }
    if (req.query.endDate) {
      conditions.push(`created_at <= $${paramCount++}`);
      values.push(req.query.endDate);
    }
    // Search by assigned user
    if (req.query.assignedTo) {
      conditions.push(`assigned_to = $${paramCount++}`);
      values.push(req.query.assignedTo);
    }

    // Automatic RM filtering: If user is an RM, filter by assigned_to
    const userId = (req as any).user?.id || (req as any).user?.sub || req.headers['x-user-id'];
    const userRoles = (req as any).user?.roles || JSON.parse(req.headers['x-user-roles'] || '[]');
    const isRM = userRoles.some((role: string) => 
      role.toLowerCase() === 'rm' || role.toLowerCase() === 'relationship_manager'
    );
    
    // If user is RM and no explicit assignedTo filter, automatically filter by their user ID
    if (isRM && userId && !req.query.assignedTo) {
      conditions.push(`assigned_to = $${paramCount++}`);
      values.push(userId);
      logger.debug('RMAutoFilter', { userId, correlationId: (req as any).correlationId });
    }
    // Search by partial application ID
    if (req.query.applicationIdPattern) {
      conditions.push(`application_id::text LIKE $${paramCount++}`);
      values.push(`%${req.query.applicationIdPattern}%`);
    }

    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
    
    // Get total count
    const countQuery = `SELECT COUNT(*) as total FROM applications ${whereClause}`;
    const countResult = await pool.query(countQuery, values);
    const total = parseInt(countResult.rows[0].total, 10);

    // Get paginated results
    values.push(limit, offset);
    const dataQuery = `
      SELECT 
        application_id, applicant_id, channel, product_code, 
        requested_amount, requested_tenure_months, status, 
        created_at, updated_at 
      FROM applications 
      ${whereClause}
      ORDER BY created_at DESC
      LIMIT $${paramCount++} OFFSET $${paramCount++}
    `;
    const { rows } = await pool.query(dataQuery, values);

    logger.debug('ListApplications', { 
      correlationId: (req as any).correlationId, 
      page, 
      limit, 
      total,
      filters: req.query 
    });

    return res.status(200).json({
      applications: rows,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
        hasMore: page * limit < total
      }
    });
  } catch (err) {
    logger.error('ListApplicationsError', { error: (err as Error).message, correlationId: (req as any).correlationId });
    return res.status(500).json({ error: 'Failed to list applications' });
  }
});

// Helper function to escape CSV values
function escapeCsv(value: any): string {
  if (value === null || value === undefined) {
    return '';
  }
  const str = String(value);
  if (str.includes(',') || str.includes('"') || str.includes('\n')) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}

// GET /api/applications/export - export applications to CSV/Excel
app.get('/api/applications/export', async (req, res) => {
  try {
    const format = (req.query.format as string || 'csv').toLowerCase();
    const maxRecords = Math.min(50000, parseInt(req.query.maxRecords as string || '10000', 10));

    // Build WHERE clause (same logic as GET /api/applications)
    const conditions: string[] = [];
    const values: any[] = [];
    let paramCount = 1;

    if (req.query.status) {
      // Support comma-separated statuses
      const statuses = (req.query.status as string).split(',').map(s => s.trim());
      if (statuses.length === 1) {
        conditions.push(`status = $${paramCount++}`);
        values.push(statuses[0]);
      } else {
        conditions.push(`status = ANY($${paramCount++})`);
        values.push(statuses);
      }
    }
    if (req.query.channel) {
      conditions.push(`channel = $${paramCount++}`);
      values.push(req.query.channel);
    }
    if (req.query.productCode) {
      conditions.push(`product_code = $${paramCount++}`);
      values.push(req.query.productCode);
    }
    if (req.query.applicantId) {
      conditions.push(`applicant_id = $${paramCount++}`);
      values.push(req.query.applicantId);
    }
    if (req.query.minAmount) {
      conditions.push(`requested_amount >= $${paramCount++}`);
      values.push(parseFloat(req.query.minAmount as string));
    }
    if (req.query.maxAmount) {
      conditions.push(`requested_amount <= $${paramCount++}`);
      values.push(parseFloat(req.query.maxAmount as string));
    }
    // Date range filters
    if (req.query.startDate) {
      conditions.push(`created_at >= $${paramCount++}`);
      values.push(req.query.startDate);
    }
    if (req.query.endDate) {
      conditions.push(`created_at <= $${paramCount++}`);
      values.push(req.query.endDate);
    }
    // Status transition filters
    if (req.query.statusAfter) {
      conditions.push(`updated_at >= $${paramCount++}`);
      values.push(req.query.statusAfter);
    }

    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

    // Get all matching records (up to maxRecords)
    const dataQuery = `
      SELECT 
        application_id, applicant_id, channel, product_code, 
        requested_amount, requested_tenure_months, status,
        assigned_to, assigned_at, withdrawn_at, withdrawn_reason,
        created_at, updated_at 
      FROM applications 
      ${whereClause}
      ORDER BY created_at DESC
      LIMIT $${paramCount++}
    `;
    
    values.push(maxRecords);
    const { rows } = await pool.query(dataQuery, values);

    if (format === 'csv') {
      // Generate CSV
      const headers = [
        'Application ID', 'Applicant ID', 'Channel', 'Product Code',
        'Requested Amount', 'Tenure (Months)', 'Status',
        'Assigned To', 'Assigned At', 'Withdrawn At', 'Withdrawn Reason',
        'Created At', 'Updated At'
      ];
      
      const csvRows = [
        headers.map(escapeCsv).join(','),
        ...rows.map((row: any) => [
          row.application_id,
          row.applicant_id,
          row.channel,
          row.product_code,
          row.requested_amount,
          row.requested_tenure_months,
          row.status,
          row.assigned_to || '',
          row.assigned_at || '',
          row.withdrawn_at || '',
          row.withdrawn_reason || '',
          row.created_at,
          row.updated_at
        ].map(escapeCsv).join(','))
      ];
      
      res.setHeader('Content-Type', 'text/csv; charset=utf-8');
      res.setHeader('Content-Disposition', `attachment; filename="applications-export-${new Date().toISOString().split('T')[0]}.csv"`);
      return res.status(200).send('\uFEFF' + csvRows.join('\n')); // BOM for Excel UTF-8 support
    } else if (format === 'json') {
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Content-Disposition', `attachment; filename="applications-export-${new Date().toISOString().split('T')[0]}.json"`);
      return res.status(200).json({
        exportedAt: new Date().toISOString(),
        totalRecords: rows.length,
        filters: req.query,
        applications: rows
      });
    } else {
      return res.status(400).json({ error: 'Unsupported format. Use "csv" or "json"' });
    }
  } catch (err) {
    logger.error('ExportApplicationsError', { error: (err as Error).message, correlationId: (req as any).correlationId });
    return res.status(500).json({ error: 'Failed to export applications' });
  }
});

// GET /api/applications/:id - get single application by ID
app.get('/api/applications/:id', async (req: Request, res: Response) => {
  try {
    const applicationId = req.params.id;
    
    // Validate UUID format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(applicationId)) {
      return res.status(400).json({ error: 'Invalid application ID format' });
    }

    const { rows } = await pool.query(
      `SELECT 
        application_id,
        applicant_id,
        status,
        channel,
        product_code,
        requested_amount,
        requested_tenure_months,
        assigned_to,
        assigned_at,
        created_at,
        updated_at
      FROM applications
      WHERE application_id = $1`,
      [applicationId]
    );

    if (rows.length === 0) {
      return res.status(404).json({ error: 'Application not found' });
    }

    logger.debug('GetApplication', {
      applicationId,
      correlationId: (req as any).correlationId
    });

    return res.status(200).json(rows[0]);
  } catch (err) {
    logger.error('GetApplicationError', {
      error: (err as Error).message,
      applicationId: req.params.id,
      correlationId: (req as any).correlationId
    });
    return res.status(500).json({ error: 'Failed to fetch application' });
  }
});

// GET /api/applications/:id/events - SSE stream for real-time updates
// GET /api/applications/:id/events - SSE stream for real-time updates
app.get('/api/applications/:id/events', (req, res) => {
  setupApplicationSSE(req, res, pool);
});

// Setup RM Dashboard endpoint
setupRMDashboardEndpoint(app, pool);

// Setup Hierarchical Dashboards (SRM and Regional Head)
setupHierarchicalDashboards(app, pool);

// Only start server if this file is run directly (not imported for tests)
if (require.main === module) {
  const port = process.env.PORT ? parseInt(process.env.PORT, 10) : 3001;
  app.listen(port, () => {
    logger.info('ApplicationServiceStarted', { port });
    console.log(`✅ Application Service started on port ${port}`);
  });
}
